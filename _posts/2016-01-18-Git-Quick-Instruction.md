---
author: 李喆
comments: true
date: 2016-02-28 10:15:10+00:00
layout: post
title: Git基本概念介绍
description: Git介绍
categories:
- guide
---
研发团队正很多人正在使用svn作为代码版本管理工具，本教程的目的是指导大家快速学习Git，文章可能有点长，但是看过本后大家的Git基本就算入门了，同时也应该具备了正确的Git观，接下来就是多多练习，完全熟练掌握Git。![](http://7xkda0.com1.z0.glb.clouddn.com/16-2-29/23395419.jpg)
<!-- more -->
#相关资源
[git官方网站](https://git-scm.com/)  
[git官方电子书](https://git-scm.com/book/en/v2)
#源码版本控制系统的发展
##集中化的版本控制系统
在这个时期分为两个阶段，首先是单机文件版本管理系统，具体的例子有windows文件版本管理等等，这个阶段时间上是没有联网的，所有操作都在本机进行，如下图所示：![](http://7xkda0.com1.z0.glb.clouddn.com/16-2-29/71628428.jpg)
第二阶段是可以联网的文件版本管理系统，具体有CVS、SVN、VSS、Proforce等等，如下图所示：![](http://7xkda0.com1.z0.glb.clouddn.com/16-2-29/30600223.jpg)
这也是我们之前最常用的源码管理解决方案，所有人都想统一的代码管理服务器或者服务器集群提交代码，如果断网则无法提交代码。
##分布式版本控制系统
这个时候Git闪亮登场了，Git采用了与以往不同的版本管理体系，采用分布式方案，每个客户端都有整个代码库完整的信息，提交代码不需要联网，只需要本地提交，本地代码可以通过push操作推到远程服务器，参与团队协作。如下图所示：![](http://7xkda0.com1.z0.glb.clouddn.com/16-2-29/92648746.jpg)
经过几十年的发展，Git成为了目前最为优秀的源码管理方式，那么Git是如何产生的呢？我们来看看Git的历史。
#Git的历史
同生活中的许多伟大事件一样,Git诞生于一个极富纷争大举创新的年代。Linux内核开源项目有着为数众多的参与者。绝大多数的Linux内核维护 工作都花在了提交补丁和保存、归档的繁琐事务上(1991-2002年间)。到 2002年,整个项组开始启用分布式版本控制系统BitKeeper来管理和维护代码。
到2005年的时候,开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束,他们收回了免费使用BitKeeper的权利。这就迫使Linux开源社区(特别是Linux的缔造者Linus Torvalds )不得不吸取教训,只有开发 一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标:  

* 速度  
* 简单的设计
* 对非线性开发模式的强力支持(允许上千个并行开发的分支)
* 完全分布式
* 有能高效管理类似Linux内核一样的超大规模项目(速度和数据量) 

所以说是时代造就了Git。
#Git基础要点
##直接快照, 而非比较差异
我们来看下面的图，版本1创建了A、B、C三个文件，版本2修改了A、C两个文件，版本3修改了C文件，版本4修改了文件A、B，版本5修改了文件B、C
![](http://7xkda0.com1.z0.glb.clouddn.com/16-2-29/3940148.jpg)
实际上每个版本只储存了变化量，我们继续看下面的图：
![](http://7xkda0.com1.z0.glb.clouddn.com/16-2-29/22264511.jpg)
虽然每个版本都存储了全部的文件信息，但实际上，如果此版本有些文件没有改动，则只对这些文件做快照，相当于用指针指向这些文件，而不是真正的在磁盘上存储这些文件。理解起来应该不困难，我们就不在赘述了。
##近乎所有操作都可以本地执行
在 Git 中的绝大多数操作都只需要访问本地文件和资源,不用连网。但如果用SVN的话,差不多所有操作都需要连接网络。因为Git在本地磁盘上就保存着所有有关当前项目的历史更新,所以处理起来速度飞快。 
##时刻保证数据完整性
在保存到Git之前,所有数据都要进行内容的校验和(checksum)计算,并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后,Git一无所知。这项特性作为Git的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整,或者磁盘损坏导致文件数据缺失,Git都能立即察觉。 
##多数操作仅添加数据
常用的Git操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作,比如删除数据,要回退或重现都会非常困难。在别的VCS中,若还未提交更新,就有可能丢失或者混淆一些修改的内容,但在Git里,一旦提交快照之后就完全不用担心丢失数据,特别是在养成了定期推送至其他镜像仓库的习惯的话。
##Git的三种状态
好,现在请注意,接下来要讲的概念非常重要。对于任何一个文件,在 Git 内都只有三种状态:已提交(committed),已修改(modified)和已暂存(staged)。已提交表示该 文件已经被安全地保存在本地数据库中了;已修改表示修改了某个文件,但还没有提交保存;已暂存表示把已修改的文件放在下次提交时要保存的清单中。
由此我们看到 Git 管理项目时,文件流转的三个工作区域:Git的本地数据目录,工作目录以及暂存区域。
![](http://7xkda0.com1.z0.glb.clouddn.com/16-2-29/72087894.jpg)
每个项目都有一个git目录,它是Git用来保存元数据和对象数据库的地方。该目录非常重要,每次克隆镜像仓库的时候,实际拷贝的就是这个目录里面的数据。
从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录。这些文件实际上都是从git目录中的压缩对象数据库中提取出来的,接下来就可以在工作目录中对这些文件进行编辑。
所谓的暂存区域只不过是个简单的文件,一般都放在git目录中。有时候人们会把这个文件叫做索引文件,不过标准说法还是叫暂存区域。
* 基本的 Git 工作流程如下所示:
	1. 在工作目录中修改某些文件。
	2. 对这些修改了的文件作快照,并保存到暂存区域。
	3. 提交更新,将保存在暂存区域的文件快照转储到 git 目录中。
所以,我们可以从文件所处的位置来判断状态:如果是git目录中保存着的特定版本文件,就属于已提交状态;如果作了修改并已放入暂存区域,就属于已暂存状态;如果自上次取出后,作了修改但还没有放到暂存区域,就是已修改状态。
